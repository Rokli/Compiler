# Лабораторная работа №1. Разработка пользовательского интерфейса (GUI) для языкового процессора.
## Цель работы: Разработать приложение – текстовый редактор. 
## Персональный вариант:
Компилятор функции инициализации константы `define()` языка PHP.
### Справка:
Этот компилятор предназначен для обработки и выполнения кода, написанного на PHP.

## Установка

### На Linux

#### Установка зависимостей:
```sh
sudo dnf install qt5-qtbase-devel qt5-qmake
```

#### Скачивание проекта:
```sh
git clone https://github.com/Rokli/Complier.git
cd Complier
```

#### Сборка проекта:
```sh
qmake
make
```

#### Запуск:
```sh
./complier
```

### На Windows

#### Установка Qt:
[Скачать и установить Qt](https://doc.qt.io/qt-6/windows.html)

#### Скачивание проекта:
```sh
git clone https://github.com/Rokli/Complier.git
cd Complier
```

#### Сборка проекта:
```sh
cd C:\path\to\Complier
qmake
mingw32-make
```

#### Запуск:
```sh
complier.exe
```

## Как пользоваться компилятором

### Файл (работа с файлами .txt)
- **Создать** — создаёт новый файл
- **Открыть** — открывает существующий файл
- **Сохранить** — сохраняет изменения в текущем файле
- **Сохранить как** — сохраняет текущий файл в указанное место
- **Выход** — закрывает приложение

### Правка (редактирование текста)
- **Отменить** — отменяет последнее изменение
- **Повторить** — повторяет последнюю операцию
- **Вырезать** — вырезает выделенный текст
- **Копировать** — копирует выделенный текст
- **Вставить** — вставляет текст из буфера обмена
- **Удалить** — удаляет выделенный текст
- **Выделить всё** — выделяет весь текст

### Пуск *(не готово)*
### Текст *(не готово)*

### Справка
- **Вызов справки** — открывает документацию в браузере
- **О программе** — отображает дополнительное окно с информацией о программе

## Обратная связь
Если у вас есть вопросы, пишите на [satalomaksimka12345678910@gmail.com](mailto:satalomaksimka12345678910@gmail.com).

# Лабораторная работа №2. Разработка лексического анализатора (сканера)
## Цель работы: Изучить назначение лексического анализатора. Спроектировать алгоритм и выполнить программную реализацию сканера.
## Персональный вариант:
Компилятор функции инициализации константы `define()` языка PHP.
### Примеры допустимых строк
- define("NAME","max")
- define("PI", 3.14159);
- define("COLORS", ["red", "green", "blue"]);
- define("bool",true)
- define("bool",false)
Этот компилятор предназначен для обработки и выполнения кода, написанного на PHP.
### Тестовые примеры
![image](https://github.com/user-attachments/assets/3676f4a1-c534-435a-9c81-78ac8968b390)
![image](https://github.com/user-attachments/assets/79a42046-a363-4299-a92c-2d42b6ac6c57)
![image](https://github.com/user-attachments/assets/ac94cc83-29ab-45dc-a321-96237f4f6f1e)


# Лабораторная работа №3. Разработка синтаксического анализатора (парсера)
## Цель работы: Изучить назначение синтаксического анализатора. Спроектировать алгоритм и выполнить программную реализацию парсера.
## Персональный вариант:
Компилятор функции инициализации константы `define()` языка PHP.\
## Грамматика:
    1. <DEF> -> 'define' <LPAREN>
    2. <LPAREN> -> '(' <MARK>
    3. <MARK> -> '"' <ID>
    4. <ID> -> letter <IDREM> 
    5. <ID> -> digit <IDREM>
    6. <IDREM> -> letter <IDREM>
    7. <IDREM> -> digit <IDREM>
    8. <IDREM> -> '"' <COMMA>
    9. <COMMA> -> ',' <VALUE>
    10.  <VALUE> -> digit <VALUEREM>
    11.  <VALUE> -> '"' <STRING>
    12.  <VALUE> -> 'true' <RPAREN>
    13.  <VALUE> -> 'false' <RPAREN>
    14.  <VALUE> -> '+' <VALUETYPE>
    15.  <VALUE> -> '-' <VALUETYPE>
    16.  <VALUETYPE> -> digit <VALUEREM>
    17.  <VALUEREM> -> digit <VALUEREM>
    18.  <VALUEREM> -> ')' <SEMICOLON>
    19.  <VALUEREM> -> '.' <DECIMAL>
    20.  <DECIMAL> -> digit <DECIMALREM>
    21.  <DECIMALREM> -> digit <DECIMALREM>
    22.  <DECIMALREM> -> ")" <SEMILICON>
    23.  <STRING> -> letter <STRINGREM>
    24.  <STRING> -> digit <STRINGREM>
    25.  <STRINGREM> -> letter <STRINGREM>
    26.  <STRINGREM> -> digit <STRINGREM
    27.  <STRINGREM> -> '"' <RPAREN>
    28.  <RPAREN> -> ')' <SEMICOLON>
    29.  <SEMICOLON> -> ';'
<letter> → "a" | "b" | "c" | ... | "z" | "A" | "B" | "C" | ... | "Z" |
<digit> → "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
## Граф:
![image](https://github.com/user-attachments/assets/a5d73092-8593-48af-b379-e2df337f3622)

### Примеры допустимых строк
- define("NAME","max")
- define("PI", 3.14159);
- define("COLORS", ["red", "green", "blue"]);
- define("bool",true)
- define("bool",false)
### Тестовые примеры:
![image](https://github.com/user-attachments/assets/386b184a-1529-4a8f-aefe-eb2452d38b73)
![image](https://github.com/user-attachments/assets/59aac5b4-9b0d-4f0a-9c19-b1a307996d6d)
![image](https://github.com/user-attachments/assets/75738ec3-d628-4149-88c4-de28ef0a26fa)


# Лабораторная работа №4. Нейтрализация ошибок (метод Айронса)
## Цель работы: Реализовать алгоритм нейтрализации синтаксических ошибок и дополнить им программную реализацию парсера.
# Задание: Реализовать алгоритм синтаксического анализа с нейтрализацией ошибок (метод Айронса). 
## Персональный вариант:
Компилятор функции инициализации константы `define()` языка PHP.
## Грамматика:
    1. <DEF> -> 'define' <LPAREN>
    2. <LPAREN> -> '(' <MARK>
    3. <MARK> -> '"' <ID>
    4. <ID> -> letter <IDREM> 
    5. <ID> -> digit <IDREM>
    6. <IDREM> -> letter <IDREM>
    7. <IDREM> -> digit <IDREM>
    8. <IDREM> -> '"' <COMMA>
    9. <COMMA> -> ',' <VALUE>
    10.  <VALUE> -> digit <VALUEREM>
    11.  <VALUE> -> '"' <STRING>
    12.  <VALUE> -> 'true' <RPAREN>
    13.  <VALUE> -> 'false' <RPAREN>
    14.  <VALUE> -> '+' <VALUETYPE>
    15.  <VALUE> -> '-' <VALUETYPE>
    16.  <VALUETYPE> -> digit <VALUEREM>
    17.  <VALUEREM> -> digit <VALUEREM>
    18.  <VALUEREM> -> ')' <SEMICOLON>
    19.  <VALUEREM> -> '.' <DECIMAL>
    20.  <DECIMAL> -> digit <DECIMALREM>
    21.  <DECIMALREM> -> digit <DECIMALREM>
    22.  <DECIMALREM> -> ")" <SEMILICON>
    23.  <STRING> -> letter <STRINGREM>
    24.  <STRING> -> digit <STRINGREM>
    25.  <STRINGREM> -> letter <STRINGREM>
    26.  <STRINGREM> -> digit <STRINGREM
    27.  <STRINGREM> -> '"' <RPAREN>
    28.  <RPAREN> -> ')' <SEMICOLON>
    29.  <SEMICOLON> -> ';'
<letter> → "a" | "b" | "c" | ... | "z" | "A" | "B" | "C" | ... | "Z" |
<digit> → "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"
## Граф:
![image](https://github.com/user-attachments/assets/a5d73092-8593-48af-b379-e2df337f3622)

### Примеры допустимых строк
- define("NAME","max")
- define("PI", 3.14159);
- define("COLORS", ["red", "green", "blue"]);
- define("bool",true)
- define("bool",false)

### Тестовые примеры:
![image](https://github.com/user-attachments/assets/2e3a86e7-536c-417b-bbfc-eee6ac6b11b0)
![image](https://github.com/user-attachments/assets/ff313b68-9adf-4064-a1ef-c0057c29c831)
![image](https://github.com/user-attachments/assets/db8eda82-ca0f-45bc-a998-68d52d55633f)
![image](https://github.com/user-attachments/assets/706e36c5-ad51-40ce-9482-e4194e2c7f83)
![image](https://github.com/user-attachments/assets/9e71d487-d90f-4ae8-bf04-40280e3a6c56)

# Лабораторная работа №5. Включение семантики в анализатор. Создание внутренней формы представления программы.
## Цель работы: Дополнить анализатор, разработанный в рамках лабораторных работ, этапом формирования внутренней формы представления программы.
## Персональный вариант:
1 вариант. В качестве внутренней формы представления программы выберем польскую инверсную запись (ПОЛИЗ). Эта форма представления наглядна и достаточно проста для последующей интерпретации, которая может быть выполнена с использованием стека.

Задание:

1) Реализовать в текстовом редакторе поиск лексических и синтаксических ошибок для грамматики G[<E>]. Реализовать данную КС-граммматику методом рекурсивного спуска:

1. E → TA 

2. A → ε | + TA | - TA 

3. T → ОВ 

4. В → ε | *ОВ | /ОВ 

5. О → num | (E) 

6. num  → digit {digit}

2) Реализовать алгоритм записи арифметических выражений в ПОЛИЗ и алгоритм вычисления выражений в ПОЛИЗ.

### Примеры допустимых строк
- 6 + 7 + 10 * 4
- 5*5*5
- 10 * 10 + 5

### Тестовые примеры:
![image](https://github.com/user-attachments/assets/585cf056-10af-46eb-9f80-a6893ea1b84d)
![image](https://github.com/user-attachments/assets/b2e9929c-68cf-4ecb-9cea-fb9150b12298)
![image](https://github.com/user-attachments/assets/0e97a5e0-6cba-48ef-9f3e-6e1cc4a896f5)

# Лабораторная работа №6. Реализация алгоритма поиска подстрок с помощью регулярных выражений.
## Цель работы: Реализовать алгоритм поиска в тексте подстрок, соответствующих заданным регулярным выражениям.
## Задачи:
### 2) Построить РВ, описывающее американские почтовые индексы.
QRegularExpression regex(R"((\d{5}(?:-\d{4})?))");
### 18)
QRegularExpression regex(R"((199[89]|200[0-4]))");
### 20)
QRegularExpression regex(R"(([+-]?(?:\d+\.?\d*|\.\d+)(?:[eE][+-]?\d+)?))");

### Тестовые примеры:
![image](https://github.com/user-attachments/assets/64b126fd-db93-482f-b3f3-baf0f04d015e)
![image](https://github.com/user-attachments/assets/47a4cfaf-773e-4b6d-b3e6-dcbc1e78a0db)
![image](https://github.com/user-attachments/assets/18c2222d-4757-4659-a4e2-177ae572c160)


# Лабораторная работа №7. Преобразование и анализ кода с использованием Clang и LLVM.
## Цель работы: Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе.
## Задачи:
### 1. Установить Clang и LLVM;

![image](https://github.com/user-attachments/assets/9dbddd9c-0407-45ac-85a7-2ad291e1b47c)

### 2. Скомпилировать простой C-файл с использованием clang и получить его: абстрактное синтаксическое дерево (AST), промежуточное представление LLVM IR;

#### Содержимое main.c

![image](https://github.com/user-attachments/assets/f6114026-43c5-43b6-8a25-348af9f5001a)

#### Команда clang -Xclang -ast-dump -fsyntax-only main.c (AST)

![image](https://github.com/user-attachments/assets/c4f69b00-3fcc-454c-a7da-527dfeb01da0)

#### Команда clang -S -emit-llvm main.c -o main.ll (LLVM IR)

![image](https://github.com/user-attachments/assets/3b9c3a1e-81f4-4f24-bb83-23bf2e056bbe)


### 3. Использовать opt для применения базовой комплексной оптимизации (например, О2);

#### Команда clang -O0 -S -emit-llvm main.c -o main_O0.ll

![image](https://github.com/user-attachments/assets/fcf72333-f68c-44d5-b45c-965d94fa666f)


#### Команда clang -O2 -S -emit-llvm main.c -o main_O2.ll

![image](https://github.com/user-attachments/assets/a1809d82-18d9-4726-94d3-1cac1ae02929)

#### Команда diff main_O0.ll main_O2.ll

![image](https://github.com/user-attachments/assets/e8c4e8d0-00cd-4f21-aee4-25c30f2fc61b)


### 4. Построить граф потока управления (CFG) для оптимизированной программы;

#### cfg_main.png

![image](https://github.com/user-attachments/assets/d986c57b-81df-4aa5-8ef8-e6103b453ac5)

#### cfg_square.png

![image](https://github.com/user-attachments/assets/efcbf301-e163-47ca-9f9b-20f4df0641d3)


### 5. Проанализировать результат, сделать выводы и ответить на контрольные вопросы;

#### 1. Что такое Clang, и какова его роль в процессе компиляции программ?

Clang является фронтендом для языков программирования C, C++, Objective-C, Objective-C++ и OpenCL C, использующимся совместно с фреймворком LLVM. Clang транслирует исходные коды в байт-код LLVM, затем фреймворк производит оптимизации и кодогенерацию.

#### 2. Что представляет собой LLVM и как он используется в современных компиляторах?

LLVM - проект программной инфраструктуры для создания компиляторов и сопутствующих им утилит. Состоит из набора компиляторов из языков высокого уровня (так называемых фронтендов), системы оптимизации, интерпретации и компиляции в машинный код.

#### 3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?

AST — это иерархическое дерево, отражающее синтаксис исходного кода (структура программных конструкций).

LLVM IR — это линейное, низкоуровневое, машинно-независимое представление, предназначенное для оптимизаций и генерации машинного кода.


#### 4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?

Для того что бы использовать одни и те же оптимизации и бэк разных языков

#### 5. Что делает инструкция alloc в LLVM IR, и зачем она используется в функциях?

alloca выделяет память на стеке для локальных переменных.
Это аналог объявления переменной в функции на C.

#### 6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?

Оптимизация улучшает производительность и/или уменьшает размер программы. 

#### 7. Что такое SSA-форма и почему она важна при оптимизации программ?

SSA - промежуточное представление, используемое компиляторами, в котором каждой переменной значение присваивается лишь единожды.
Это упрощает анализ зависимостей между переменными.

#### 8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?

CFG — это граф, где вершины — базовые блоки, а рёбра — переходы управления.
Он позволяет анализировать все возможные пути выполнения и применять оптимизации 

#### 9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?

%result = add i32 %a, %b — сложение двух 32-битных чисел.

%result = mul i32 %a, %b — умножение.

#### 10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?

Функции изолированы, их можно анализировать независимо.

#### 11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?

Компилятор может применить инлайнинг — заменить вызов функции её телом, чтобы сократить накладные расходы и раскрыть больше возможностей для оптимизации.

#### 12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?

IR проще для анализа, так как уже устранены синтаксические и семантические сложности C.

CFG позволяет точно анализировать потоки исполнения.

Оптимизации становятся более надёжными, платформо-независимыми и масштабируемыми.














































